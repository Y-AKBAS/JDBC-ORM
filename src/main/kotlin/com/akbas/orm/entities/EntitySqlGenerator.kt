package com.akbas.orm.entities

import com.akbas.orm.support.ConstructorParameter
import com.akbas.orm.pagination.PaginationQuery
import com.akbas.orm.pagination.PaginationQueryComponents
import com.akbas.orm.pagination.SortOrder

class EntitySqlGenerator<T>(
    private val tableName: String,
    private val idParam: ConstructorParameter,
    private val constructorParameters: List<ConstructorParameter>,
) {

    private val paramsWithoutId = constructorParameters.filter { it.name != idParam.name }

    private val insertWithIdSql by lazy { insertSql(true) }
    private val insertWithoutIdSql by lazy { insertSql(false) }
    private val namedInsertWithIdSql by lazy { namedInsertWithIdSql() }
    private val namedInsertWithoutIdSql by lazy { namedInsertWithoutIdSql() }
    private val selectClause by lazy { selectClause() }
    private val fromClause by lazy { fromClause() }

    val findByIdSql by lazy { findById() }
    val findByIdsSql by lazy { findByIdsSql() }
    val findAllSql by lazy { findAll() }
    val updateOneSql by lazy { update() }
    val deleteByIdSql by lazy { deleteById() }
    val deleteByIdsSql by lazy { deleteByIds() }
    val deleteAllSql by lazy { deleteAll() }
    val countSql by lazy { count() }
    val namedFindByIdSql by lazy { namedFindById() }
    val namedFindByIdsSql by lazy { namedFindByIdsSql() }
    val namedFindAllSql by lazy { namedFindAll() }
    val namedUpdateOneSql by lazy { namedUpdate() }

    private var isIdGenerated: Boolean? = null

    fun isIdAutoGenerated(instance: T): Boolean {
        if (this.isIdGenerated != null) return isIdGenerated!!
        synchronized(this) {
            if (this.isIdGenerated == null) {
                val id = idParam.property.call(instance)
                isIdGenerated = id == null
            }
        }

        return isIdGenerated!!
    }

    fun getInsertSql(instance: T): String {
        return if (isIdAutoGenerated(instance)) insertWithoutIdSql else insertWithIdSql
    }

    fun getNamedInsertSql(instance: T): String {
        return if (isIdAutoGenerated(instance)) namedInsertWithoutIdSql else namedInsertWithIdSql
    }

    fun getInsertSql(instances: Collection<T>): String = buildString {
        require(instances.isNotEmpty()) { "Nothing to insert!" }
        val params = if (isIdAutoGenerated(instances.first())) {
            paramsWithoutId
        } else {
            constructorParameters
        }
        append("INSERT INTO $tableName ")
        append(params.joinToString(prefix = "(", postfix = ") ") { it.snakeCaseName })
        append("VALUES ")
        val valueString = params.indices.joinToString(prefix = "(", separator = ",", postfix = ")") { "?" }
        repeat(instances.size - 1) { append(valueString); append(",") }
        append(valueString)
    }

    fun <K : Comparable<K>?> count(components: PaginationQueryComponents<K>) = buildString {
        append("SELECT COUNT(*) ")
        append(paginationQueryBody(components))
    }.normalize()

    fun <K : Comparable<K>?> paginationQuery(paginationQuery: PaginationQuery<K>, isInitial: Boolean) = buildString {
        append(selectClause)
        append(" ")
        append(if (isInitial) initialPaginationQueryBody(paginationQuery.components) else paginationQueryBody(paginationQuery.components))
        append(" LIMIT ")
        append(paginationQuery.limit)
        append(" OFFSET ")
        append(paginationQuery.offset)
    }.normalize()

    private fun <K : Comparable<K>?> initialPaginationQueryBody(components: PaginationQueryComponents<K>) = buildString {
        append(fromClause)
        if (components.whereClause != null) {
            generateWhere(components.whereClause)
        }
        if (components.groupByClause != null) {
            append(components.groupByClause)
        }
        append(" ORDER BY ")
        append(components.sortKey.snakeCaseName)
        append(" ")
        append(components.sortKey.sortOrder.name)
    }

    private fun <K : Comparable<K>?> paginationQueryBody(components: PaginationQueryComponents<K>) = buildString {
        append(fromClause)
        if (components.whereClause != null) {
            generateWhere(components.whereClause)
            append(" AND ")
        } else {
            append(" WHERE ")
        }
        append(" ( ")
        append(components.sortKey.snakeCaseName)
        append(if (components.sortKey.sortOrder == SortOrder.ASC) " > " else " < ")
        append(":")
        append(components.sortKey.property.name)
        append(" ) ")
        if (components.groupByClause != null) {
            append(components.groupByClause)
        }
        append(" ORDER BY ")
        append(components.sortKey.snakeCaseName)
        append(" ")
        append(components.sortKey.sortOrder.name)
    }

    private fun selectClause() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",", postfix = " ") { it.snakeCaseName })
    }

    private fun fromClause(): String = "FROM $tableName "

    private fun StringBuilder.generateWhere(whereClause: String) {
        val cleanedWhere = whereClause.trim()
        require(cleanedWhere.startsWith("where", true)) { "WHERE clause doesn't start with case ignored WHERE!" }
        val whereRemoved = cleanedWhere.substring("WHERE ".length)
        append("WHERE ( ")
        append(whereRemoved)
        append(" )")
    }

    private fun insertSql(withId: Boolean) = buildString {
        val targetParams = if (withId) constructorParameters else paramsWithoutId
        append("INSERT INTO $tableName ")
        append(targetParams.joinToString(prefix = "(", postfix = ")") { it.snakeCaseName })
        append(" VALUES (")
        repeat(targetParams.size - 1) { append("?,") }
        append("?)")
    }

    private fun findById() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName ")
        append(" WHERE ${idParam.snakeCaseName} = ?")
    }

    private fun findByIdsSql() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName ")
        append("WHERE ${idParam.snakeCaseName} IN (:ids)")
    }

    private fun findAll() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName")
    }

    private fun update() = buildString {
        append("UPDATE $tableName SET")
        val lastIndex = paramsWithoutId.size - 1
        paramsWithoutId.forEachIndexed { i, param ->
            append(" ${param.snakeCaseName} = ?")
            if (i < lastIndex) append(",")
        }
        append(" WHERE ${idParam.snakeCaseName} = ?")
    }

    private fun deleteById() = buildString {
        append("DELETE FROM $tableName ")
        append("WHERE ${idParam.snakeCaseName} = ?")
    }

    private fun deleteByIds() = buildString {
        append("DELETE FROM $tableName ")
        append("WHERE ${idParam.snakeCaseName} IN (:ids)")
    }

    private fun deleteAll() = "DELETE FROM $tableName"

    private fun count() = "SELECT COUNT(*) FROM $tableName"

    private fun namedInsertWithIdSql() = buildString {
        append("INSERT INTO $tableName ")
        append(constructorParameters.joinToString(prefix = "(", postfix = ")") { it.snakeCaseName })
        append(" VALUES ")
        append(constructorParameters.joinToString(prefix = "(", postfix = ")") { ":${it.name}" })
    }.normalize()

    private fun namedInsertWithoutIdSql() = buildString {
        append("INSERT INTO $tableName ")
        append(constructorParameters.filter { it.name != idParam.name }.joinToString(prefix = "(", postfix = ")") { it.snakeCaseName })
        append(" VALUES ")
        append(constructorParameters.filter { it.name != idParam.name }.joinToString(prefix = "(", postfix = ")") { ":${it.name}" })
    }.normalize()

    private fun namedFindById() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName ")
        append(" WHERE ${idParam.snakeCaseName} = :${idParam.name}")
    }.normalize()

    private fun namedFindByIdsSql() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName ")
        append("WHERE ${idParam.snakeCaseName} IN (:ids)")
    }.normalize()

    private fun namedFindAll() = buildString {
        append("SELECT ")
        append(constructorParameters.joinToString(",") { it.snakeCaseName })
        append(" FROM $tableName")
    }.normalize()

    private fun namedUpdate() = buildString {
        append("UPDATE $tableName SET")
        val paramsWithoutId = constructorParameters.filter { it.name != idParam.name }
        val lastIndex = paramsWithoutId.size - 1
        paramsWithoutId.forEachIndexed { i, param ->
            append(" ${param.snakeCaseName} = :${param.name}")
            if (i < lastIndex) append(",")
        }
        append(" WHERE ${idParam.snakeCaseName} = :${idParam.name}")
    }.normalize()

    private fun String.normalize(): String = this.trim().replace(Regex("\\s+"), " ")
}
