package com.akbas.orm.entities

import com.akbas.orm.support.JdbcMappingManager
import com.zaxxer.hikari.HikariDataSource
import org.springframework.boot.autoconfigure.jdbc.JdbcConnectionDetails
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.core.namedparam.SqlParameterSource
import org.springframework.jdbc.core.simple.JdbcClient
import org.springframework.jdbc.support.GeneratedKeyHolder
import java.util.stream.Stream
import javax.sql.DataSource
import kotlin.reflect.cast
import kotlin.reflect.full.primaryConstructor
import kotlin.reflect.jvm.jvmErasure

class EntityDao private constructor(
    private val dataSource: DataSource,
    val jdbcClient: JdbcClient,
    val namedTemplate: NamedParameterJdbcTemplate,
    private val readOnly: Boolean
) {

    companion object {

        const val GENERATED_KEY = "GENERATED_KEY"

        fun create(connectionDetails: JdbcConnectionDetails, readOnly: Boolean): EntityDao {
            val dataSource = createDataSource(connectionDetails)
            val jdbcTemplate = JdbcTemplate(dataSource).apply { fetchSize = Int.MIN_VALUE }
            val namedTemplate = NamedParameterJdbcTemplate(jdbcTemplate)
            val jdbcClient = JdbcClient.create(namedTemplate)
            return EntityDao(dataSource, jdbcClient, namedTemplate, readOnly)
        }

        fun create(dataSource: DataSource, readOnly: Boolean): EntityDao {
            val jdbcTemplate = JdbcTemplate(dataSource).apply { fetchSize = Int.MIN_VALUE }
            val namedTemplate = NamedParameterJdbcTemplate(jdbcTemplate)
            val jdbcClient = JdbcClient.create(namedTemplate)
            return EntityDao(dataSource, jdbcClient, namedTemplate, readOnly)
        }

        private fun createDataSource(connectionDetails: JdbcConnectionDetails): DataSource {
            return DataSourceBuilder.create()
                .type(HikariDataSource::class.java)
                .url(connectionDetails.jdbcUrl)
                .username(connectionDetails.username)
                .password(connectionDetails.password)
                .driverClassName(connectionDetails.driverClassName)
                .build()
        }
    }

    inline fun <reified T : Any> insert(entity: T): T {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.getInsertSql(instance = entity)
        val autoGenerated = mappingManager.sqlGenerator.isIdAutoGenerated(instance = entity)
        val params = mappingManager.paramGenerator.toInsertParam(entity, autoGenerated)
        val keyHolder = if (autoGenerated) GeneratedKeyHolder() else null
        return executeInsert(keyHolder, params, mappingManager, entity, sql)
    }

    inline fun <reified T : Any> insertAll(entities: List<T>): List<T> {
        checkReadOnly()
        if (entities.isEmpty()) return emptyList()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.getInsertSql(instances = entities)
        val autoGenerated = mappingManager.sqlGenerator.isIdAutoGenerated(instance = entities.first())
        val params = mappingManager.paramGenerator.toInsertParams(entities, autoGenerated)
        val keyHolder = if (autoGenerated) GeneratedKeyHolder() else null
        return executeInserts(keyHolder, params, mappingManager, entities, sql)
    }

    inline fun <reified T : Any, ID> findByIdOrNull(id: ID): T? {
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.findByIdSql
        val entity = jdbcClient.sql(sql)
            .param(id)
            .query(mappingManager.mapper)
            .optional()
            .orElse(null)

        return entity
    }

    inline fun <reified T : Any, ID> findByIds(ids: Collection<ID>): List<T> {
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.findByIdsSql
        val entities = jdbcClient.sql(sql)
            .params(mapOf("ids" to ids))
            .query(mappingManager.mapper)
            .list()

        return entities
    }

    inline fun <reified T : Any> findAll(sql: String, params: List<*>? = null, namedParams: SqlParameterSource? = null): List<T> {
        val mappingManager = JdbcMappingManager.of(T::class)
        val mapper = mappingManager.mapper
        if (params == null && namedParams == null) return jdbcClient.sql(sql).query(mapper).list()

        if (params != null && namedParams != null) throw IllegalArgumentException("Either params or namedParams should be provided!")

        val entities = if (params != null) {
            return jdbcClient.sql(sql)
                .params(params)
                .query(mappingManager.mapper)
                .list()
        } else {
            namedTemplate.query(sql, namedParams!!, mappingManager.mapper)
        }

        return entities
    }

    inline fun <reified T : Any> streamAll(sql: String, params: List<*>? = null, namedParams: SqlParameterSource? = null): Stream<T> {
        val mappingManager = JdbcMappingManager.of(T::class)
        val mapper = mappingManager.mapper
        if (params == null && namedParams == null) return jdbcClient.sql(sql).query(mapper).stream()

        if (params != null && namedParams != null) throw IllegalArgumentException("Either params or namedParams should be provided!")

        val entities = if (params != null) {
            return jdbcClient.sql(sql)
                .params(params)
                .query(mappingManager.mapper)
                .stream()
        } else {
            namedTemplate.queryForStream(sql, namedParams!!, mappingManager.mapper)
        }

        return entities
    }

    inline fun <reified T : Any> findAll(): List<T> {
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.findAllSql
        val entities: List<T> = jdbcClient.sql(sql)
            .query(mappingManager.mapper)
            .list()

        return entities
    }

    inline fun <reified T : Any> streamAll(): Stream<T> {
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.findAllSql
        val entities: Stream<T> = jdbcClient.sql(sql)
            .query(mappingManager.mapper)
            .stream()

        return entities
    }

    inline fun <reified T : Any> updateOne(entity: T): Int {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.updateOneSql
        val params = mappingManager.paramGenerator.toUpdateParam(entity)
        val updateCount = jdbcClient.sql(sql)
            .params(*params)
            .update()

        return updateCount
    }

    inline fun <reified T : Any> updateAll(entities: List<T>) {
        checkReadOnly()
        if (entities.isEmpty()) return
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.namedUpdateOneSql
        val mapper = mappingManager.mapper
        val parameterSources = Array<SqlParameterSource?>(entities.size) { null }
        entities.forEachIndexed { index, t ->
            parameterSources[index] = mapper.createSqlParameterSource(t)
        }
        namedTemplate.batchUpdate(sql, parameterSources)
    }

    inline fun <reified T : Any> remove(entity: T): Int {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.deleteByIdSql
        val params = mappingManager.paramGenerator.toDeleteByIdParam(entity)
        val updateCount = jdbcClient.sql(sql).params(*params).update()
        return updateCount
    }

    inline fun <reified T : Any, ID> removeByIds(ids: Collection<ID>): Int {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.deleteByIdsSql
        val updateCount = jdbcClient.sql(sql).params(mapOf("ids" to ids)).update()
        return updateCount
    }

    inline fun <reified T : Any> removeAll(entities: Collection<T>): Int {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.deleteByIdsSql
        val params = mappingManager.paramGenerator.toDeleteByIdsParam(entities)
        val updateCount = jdbcClient.sql(sql).params(mapOf("ids" to params)).update()
        return updateCount
    }

    inline fun <reified T : Any> removeAll(): Int {
        checkReadOnly()
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.deleteAllSql
        val updateCount = jdbcClient.sql(sql).update()
        return updateCount
    }

    inline fun <reified T : Any> count(): Long {
        val mappingManager = JdbcMappingManager.of(T::class)
        val sql = mappingManager.sqlGenerator.countSql
        val count = jdbcClient.sql(sql).query().singleValue() as Long
        return count
    }

    fun <T : Any> executeInsert(
        keyHolder: GeneratedKeyHolder?,
        params: Array<Any?>,
        mappingManager: JdbcMappingManager<T>,
        entity: T,
        sql: String
    ): T {
        checkReadOnly()
        val statement = jdbcClient.sql(sql)
        if (keyHolder != null) {
            val effectedColumns = statement.params(*params).update(keyHolder, mappingManager.idParam.snakeCaseName)
            check(effectedColumns != 0) { "Unable to insert entity with sql: $sql" }
            return getInsertResult(entity, keyHolder.keyList.first(), mappingManager, params)
        } else {
            val effectedColumns = statement.params(*params).update()
            check(effectedColumns != 0) { "Unable to insert entity with sql: $sql" }
            return getInsertResult(entity, null, mappingManager, params)
        }
    }

    fun <T : Any> executeInserts(
        keyHolder: GeneratedKeyHolder?,
        params: Array<Any?>,
        mappingManager: JdbcMappingManager<T>,
        entities: List<T>,
        sql: String
    ): List<T> {
        checkReadOnly()
        val statement = jdbcClient.sql(sql)
        val numOfEntityParams = params.size / entities.size
        if (keyHolder != null) {
            val effectedColumns = statement.params(*params).update(keyHolder, mappingManager.idParam.snakeCaseName)
            check(effectedColumns == entities.size) { "Could insert $effectedColumns entities with sql: $sql" }
            return keyHolder.keyList.mapIndexed { index, keyMap ->
                val paramIndex = index * numOfEntityParams
                val entityParams = params.sliceArray((paramIndex until paramIndex + numOfEntityParams))
                getInsertResult(entities[index], keyMap, mappingManager, entityParams)
            }
        } else {
            val effectedColumns = statement.params(*params).update()
            check(effectedColumns != 0) { "Unable to insert entity with sql: $sql" }
            return entities.mapIndexed { index, entity ->
                val paramIndex = index * numOfEntityParams
                val entityParams = params.sliceArray((paramIndex until paramIndex + numOfEntityParams))
                getInsertResult(entity, null, mappingManager, entityParams)
            }
        }
    }

    private fun <T : Any> getInsertResult(entity: T, keyHolder: Map<String, Any>?, mappingManager: JdbcMappingManager<T>, params: Array<Any?>): T {
        if (keyHolder == null) return entity::class.primaryConstructor!!.call(*mappingManager.paramGenerator.toConstructorParams(params))

        val expectedType = mappingManager.idParam.property.returnType.jvmErasure
        val generatedKey = keyHolder[GENERATED_KEY]
        requireNotNull(generatedKey) { "DB didn't generate any keys! Should you provide them yourself?" }
        val constructorParameters = if (generatedKey is Number) {
            val key: Any = when (expectedType) {
                Long::class -> generatedKey.toLong()
                Int::class -> generatedKey.toInt()
                else -> throw IllegalStateException("Please add your key type to this when expression!")
            }
            mappingManager.paramGenerator.toConstructorParams(params, key)
        } else {
            mappingManager.paramGenerator.toConstructorParams(params, expectedType.cast(generatedKey))
        }

        return entity::class.primaryConstructor!!.call(*constructorParameters)
    }

    fun checkReadOnly() = check(!readOnly) { "Dao is read only!" }
}
